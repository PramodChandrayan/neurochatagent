name: üóÑÔ∏è Database Migration & Schema Management

on:
  push:
    branches: [ main, develop ]
    paths: 
      - 'migrations/**'
      - 'models/**'
      - 'database/**'
      - 'requirements.txt'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'migrations/**'
      - 'models/**'
      - 'database/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      migration_type:
        description: 'Migration Type'
        required: true
        default: 'auto'
        type: choice
        options:
        - auto
        - manual
        - rollback
      force_migrate:
        description: 'Force migration (bypass checks)'
        required: false
        default: false
        type: boolean

# üîê Required permissions for database operations
permissions:
  contents: read            # Required for reading repository contents
  actions: read             # Required for accessing GitHub Actions
  id-token: write           # Required for GCP authentication

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: asia-south1
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  MIGRATION_DATABASE_URL: ${{ secrets.MIGRATION_DATABASE_URL }}

jobs:
  # üîç MIGRATION VALIDATION
  validate-migrations:
    name: üîç Validate Migration Files
    runs-on: ubuntu-latest
    outputs:
      migration-status: ${{ steps.migration-check.outputs.status }}
      migration-files: ${{ steps.migration-check.outputs.files }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install alembic sqlalchemy psycopg2-binary

      - name: üîç Check for migration files
        id: migration-check
        run: |
          echo "üîç Checking for database migration files..."
          
          # Check for migration files
          if [ -d "migrations" ]; then
            MIGRATION_COUNT=$(find migrations -name "*.py" -type f | wc -l)
            echo "üìä Found $MIGRATION_COUNT migration files"
            
            # Check for new migrations
            NEW_MIGRATIONS=$(find migrations -name "*.py" -type f -newer .git/HEAD~1 2>/dev/null | wc -l)
            echo "üÜï Found $NEW_MIGRATIONS new migration files"
            
            if [ $NEW_MIGRATIONS -gt 0 ]; then
              echo "status=has_migrations" >> $GITHUB_OUTPUT
              echo "files=$NEW_MIGRATIONS" >> $GITHUB_OUTPUT
            else
              echo "status=no_migrations" >> $GITHUB_OUTPUT
              echo "files=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "üìÅ No migrations directory found"
            echo "status=no_migrations" >> $GITHUB_OUTPUT
            echo "files=0" >> $GITHUB_OUTPUT
          fi

      - name: üîç Validate migration syntax
        if: steps.migration-check.outputs.status == 'has_migrations'
        run: |
          echo "üîç Validating migration syntax..."
          
          # Check Python syntax
          for file in $(find migrations -name "*.py" -type f); do
            echo "üìù Checking $file..."
            python -m py_compile "$file" || exit 1
          done
          
          echo "‚úÖ All migration files have valid Python syntax"

      - name: üîç Check migration dependencies
        if: steps.migration-check.outputs.status == 'has_migrations'
        run: |
          echo "üîç Checking migration dependencies..."
          
          # Check if all required imports are available
          python -c "
          import sys
          sys.path.append('migrations')
          
          try:
              import alembic
              print('‚úÖ Alembic available')
          except ImportError:
              print('‚ùå Alembic not available')
              sys.exit(1)
          "

  # üß™ MIGRATION TESTING
  test-migrations:
    name: üß™ Test Migrations
    runs-on: ubuntu-latest
    needs: validate-migrations
    if: needs.validate-migrations.outputs.migration-status == 'has_migrations'
    outputs:
      test-status: ${{ steps.test-results.outputs.status }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install alembic sqlalchemy psycopg2-binary pytest-django

      - name: üóÑÔ∏è Set up test database
        run: |
          echo "üóÑÔ∏è Setting up test database..."
          
          # Create test database configuration
          cat > test_db_config.py << EOF
          import os
          os.environ['DATABASE_URL'] = 'sqlite:///test_migrations.db'
          os.environ['TESTING'] = 'true'
          EOF

      - name: üß™ Run migration tests
        id: test-results
        run: |
          echo "üß™ Testing migrations..."
          
          # Test migration files individually
          for file in $(find migrations -name "*.py" -type f); do
            echo "üß™ Testing $file..."
            python -c "
            import sys
            sys.path.append('migrations')
            
            try:
                exec(open('$file').read())
                print('‚úÖ $file passed')
            except Exception as e:
                print(f'‚ùå $file failed: {e}')
                sys.exit(1)
            "
          done
          
          echo "‚úÖ All migration tests passed"
          echo "status=passed" >> $GITHUB_OUTPUT

      - name: üßπ Cleanup test database
        if: always()
        run: |
          echo "üßπ Cleaning up test database..."
          rm -f test_migrations.db
          rm -f test_db_config.py

  # üóÑÔ∏è STAGING MIGRATION
  migrate-staging:
    name: üóÑÔ∏è Migrate Staging Database
    runs-on: ubuntu-latest
    needs: [validate-migrations, test-migrations]
    if: |
      needs.validate-migrations.outputs.migration-status == 'has_migrations' &&
      needs.test-migrations.outputs.test-status == 'passed' &&
      (github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    environment: staging
    outputs:
      migration-version: ${{ steps.migration-execute.outputs.version }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.PROJECT_ID }}

      - name: üóÑÔ∏è Execute staging migration
        id: migration-execute
        run: |
          echo "üóÑÔ∏è Executing staging database migration..."
          
          # Set staging environment
          export ENVIRONMENT=staging
          export DATABASE_URL="${{ secrets.STAGING_DATABASE_URL }}"
          
          # Run migrations
          if [ -f "migrations/run_migrations.py" ]; then
            python migrations/run_migrations.py --environment=staging
          else
            # Use Alembic if available
            if command -v alembic &> /dev/null; then
              alembic upgrade head
            else
              echo "‚ùå No migration runner found"
              exit 1
            fi
          fi
          
          # Get current migration version
          if command -v alembic &> /dev/null; then
            VERSION=$(alembic current | grep -o '[a-f0-9]\{12\}' | head -1)
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          else
            echo "version=unknown" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Staging migration completed"

      - name: üß™ Verify staging migration
        run: |
          echo "üß™ Verifying staging migration..."
          
          # Run verification queries
          python -c "
          import os
          import psycopg2
          
          try:
              conn = psycopg2.connect('${{ secrets.STAGING_DATABASE_URL }}')
              cursor = conn.cursor()
              
              # Check if tables exist
              cursor.execute(\"\"\"
                  SELECT table_name 
                  FROM information_schema.tables 
                  WHERE table_schema = 'public'
              \"\"\")
              
              tables = cursor.fetchall()
              print(f'‚úÖ Found {len(tables)} tables in staging database')
              
              cursor.close()
              conn.close()
          except Exception as e:
              print(f'‚ùå Verification failed: {e}')
              exit(1)
          "

  # üóÑÔ∏è PRODUCTION MIGRATION
  migrate-production:
    name: üóÑÔ∏è Migrate Production Database
    runs-on: ubuntu-latest
    needs: [validate-migrations, test-migrations, migrate-staging]
    if: |
      needs.validate-migrations.outputs.migration-status == 'has_migrations' &&
      needs.test-migrations.outputs.test-status == 'passed' &&
      (github.ref == 'refs/heads/main' || 
       (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'))
    environment: production
    outputs:
      production-version: ${{ steps.migration-execute.outputs.version }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.PROJECT_ID }}

      - name: üóÑÔ∏è Backup production database
        run: |
          echo "üóÑÔ∏è Creating production database backup..."
          
          # Create backup timestamp
          BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_NAME="production_backup_${BACKUP_TIMESTAMP}"
          
          # Create backup (example for PostgreSQL)
          if command -v pg_dump &> /dev/null; then
            pg_dump "${{ secrets.PRODUCTION_DATABASE_URL }}" > "${BACKUP_NAME}.sql"
            echo "‚úÖ Production backup created: ${BACKUP_NAME}.sql"
          else
            echo "‚ö†Ô∏è pg_dump not available, skipping backup"
          fi

      - name: üóÑÔ∏è Execute production migration
        id: migration-execute
        run: |
          echo "üóÑÔ∏è Executing production database migration..."
          
          # Set production environment
          export ENVIRONMENT=production
          export DATABASE_URL="${{ secrets.PRODUCTION_DATABASE_URL }}"
          
          # Run migrations with extra caution
          if [ -f "migrations/run_migrations.py" ]; then
            python migrations/run_migrations.py --environment=production --dry-run
            echo "‚úÖ Dry run completed successfully"
            
            # Ask for confirmation (manual step)
            echo "üîÑ Proceeding with actual migration..."
            python migrations/run_migrations.py --environment=production
          else
            # Use Alembic if available
            if command -v alembic &> /dev/null; then
              # Dry run first
              alembic upgrade head --sql
              echo "‚úÖ Dry run completed successfully"
              
              # Actual migration
              alembic upgrade head
            else
              echo "‚ùå No migration runner found"
              exit 1
            fi
          fi
          
          # Get current migration version
          if command -v alembic &> /dev/null; then
            VERSION=$(alembic current | grep -o '[a-f0-9]\{12\}' | head -1)
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          else
            echo "version=unknown" >> $GITHUB_OUTPUT
          fi
          
          echo "‚úÖ Production migration completed"

      - name: üß™ Verify production migration
        run: |
          echo "üß™ Verifying production migration..."
          
          # Run verification queries
          python -c "
          import os
          import psycopg2
          
          try:
              conn = psycopg2.connect('${{ secrets.PRODUCTION_DATABASE_URL }}')
              cursor = conn.cursor()
              
              # Check if tables exist
              cursor.execute(\"\"\"
                  SELECT table_name 
                  FROM information_schema.tables 
                  WHERE table_schema = 'public'
              \"\"\")
              
              tables = cursor.fetchall()
              print(f'‚úÖ Found {len(tables)} tables in production database')
              
              # Check data integrity
              cursor.execute(\"\"\"
                  SELECT COUNT(*) FROM information_schema.tables 
                  WHERE table_schema = 'public'
              \"\"\")
              
              table_count = cursor.fetchone()[0]
              if table_count > 0:
                  print(f'‚úÖ Database has {table_count} tables with data')
              else:
                  print('‚ö†Ô∏è Database appears to be empty')
              
              cursor.close()
              conn.close()
          except Exception as e:
              print(f'‚ùå Verification failed: {e}')
              exit(1)
          "

      - name: üîÑ Rollback preparation
        if: always()
        run: |
          echo "üîÑ Preparing rollback plan..."
          
          # Create rollback script
          cat > rollback_plan.md << EOF
          # Rollback Plan for Migration
          
          ## Migration Details
          - **Version**: ${{ needs.migrate-staging.outputs.migration-version }}
          - **Timestamp**: $(date)
          - **Environment**: Production
          
          ## Rollback Commands
          
          ### Option 1: Alembic Rollback
          \`\`\`bash
          alembic downgrade -1
          \`\`\`
          
          ### Option 2: Manual Rollback
          \`\`\`bash
          # Restore from backup
          psql "${{ secrets.PRODUCTION_DATABASE_URL }}" < production_backup_*.sql
          \`\`\`
          
          ## Emergency Contacts
          - **DBA Team**: dba@neurogent.ai
          - **DevOps Team**: devops@neurogent.ai
          
          EOF
          
          echo "‚úÖ Rollback plan created: rollback_plan.md"

  # üìä MIGRATION MONITORING
  monitor-migrations:
    name: üìä Monitor Migration Status
    runs-on: ubuntu-latest
    needs: [migrate-staging, migrate-production]
    if: always()
    steps:
      - name: üìä Migration summary
        run: |
          echo "üìä Migration Summary:"
          echo "====================="
          echo "Staging Migration: ${{ needs.migrate-staging.result }}"
          echo "Production Migration: ${{ needs.migrate-production.result }}"
          
          if [ "${{ needs.migrate-staging.result }}" == "success" ]; then
            echo "‚úÖ Staging migration successful"
            echo "   Version: ${{ needs.migrate-staging.outputs.migration-version }}"
          else
            echo "‚ùå Staging migration failed"
          fi
          
          if [ "${{ needs.migrate-production.result }}" == "success" ]; then
            echo "‚úÖ Production migration successful"
            echo "   Version: ${{ needs.migrate-production.outputs.production-version }}"
          else
            echo "‚ùå Production migration failed"
          fi

      - name: üîî Send notifications
        if: always()
        run: |
          echo "üîî Sending migration notifications..."
          
          # Add your notification logic here
          # Slack, email, etc.
          
          if [ "${{ needs.migrate-production.result }}" == "success" ]; then
            echo "‚úÖ Production migration completed successfully"
          else
            echo "‚ùå Production migration failed - immediate attention required"
          fi

  # üîÑ MIGRATION ROLLBACK
  rollback-migration:
    name: üîÑ Rollback Migration (Manual)
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.migration_type == 'rollback'
    environment: production
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ env.PROJECT_ID }}

      - name: üîÑ Execute rollback
        run: |
          echo "üîÑ Executing migration rollback..."
          
          # Check for rollback plan
          if [ -f "rollback_plan.md" ]; then
            echo "üìã Rollback plan found"
            cat rollback_plan.md
          fi
          
          # Execute rollback
          if command -v alembic &> /dev/null; then
            echo "üîÑ Rolling back with Alembic..."
            alembic downgrade -1
            echo "‚úÖ Rollback completed"
          else
            echo "‚ùå Alembic not available for rollback"
            exit 1
          fi

      - name: üß™ Verify rollback
        run: |
          echo "üß™ Verifying rollback..."
          
          # Verify database state after rollback
          python -c "
          import psycopg2
          
          try:
              conn = psycopg2.connect('${{ secrets.PRODUCTION_DATABASE_URL }}')
              cursor = conn.cursor()
              
              cursor.execute(\"\"\"
                  SELECT table_name 
                  FROM information_schema.tables 
                  WHERE table_schema = 'public'
              \"\"\")
              
              tables = cursor.fetchall()
              print(f'‚úÖ Rollback verification: {len(tables)} tables found')
              
              cursor.close()
              conn.close()
          except Exception as e:
              print(f'‚ùå Rollback verification failed: {e}')
              exit(1)
          "
